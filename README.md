# ***3-BIT-Gray-Code-Counter***
## ***Introduction***
This report presents the design and implementation of a 3-bit gray code counter using D flip-flops. Gray Code is the minimum-change code category of coding in which,the two consecutive values changes by only a single bit. More specifically we can say, itis a binary number system where while moving from one step to the next, only a single bit shows variation. The objective of this project is to develop 3-bit gray code counter capable of producing the expected sequence is 000,001, 011, 010,..., 101,100. Verilog hardware description language is employed for the implementation. Additionally, a test bench based on Object-Oriented Programming (OOP) is developed to validate the counters behavior, treating the design as a black box, enabling efficient representation and simulation of the counter’s behavior. In conclusion, a 3-bit gray code successfully generates a binary code sequencewhere successive numbers differ by only one bit. In other words, in gray code, only one-bit changes between two consecutive numbers. The report demonstrates the effectiveness of the proposed design and highlights the significance of synchronous reset in ensuring reliable operation. The project contributes to a deeper understanding of digital sequential circuits and their applications in various digital systems

## ***What is a Gray Code Counter***
Gray code is a binary numeral system where two successive values differ
in only one bit position. This makes it useful in applications like digital encoders,
rotary encoders, and minimizing glitches when transitioning between numbers.
A Gray code counter using D flip-flops can be implemented to generate a
sequenceof gray code numbers.
The standard Gray Code sequence for a 3-bit counter is: 000, 001, 011, 010, 110,
111,101, 100, and then repeat. Gray code, also known as reflected binary code
or unit distance code, is a binary numeral system where two successive values
differ in only one bit position. It is named after Frank Gray, who patented the
binary code sequence in 1953, although it was independently discovered and
used earlier.
In traditional binary counting, when we increment from one number to the next,
multiple bits can change simultaneously, leading to potential glitches or errors in
some applications unlike the Gray Code.

## ***Design and Implementation***
### ***Gray Code Counter Circuit diagram*** ###
![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/76324055-c0fc-4813-a3d8-6085e7c9968b)<br>

### ***Gray Code Counter state diagram*** ###
![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/db41f326-9b02-43d3-a4e2-869ea23b6a4c)

## ***Tech Stack***
[Vivado ML Edition - 2023.1](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2023-1.html) used to implement the code.

## ***Working***

The working of a Gray Code Counter involves generation of gray code
using D flip-flops. The step-by-step operation of the counter is given below:
1. Initialization:
• The 3-bit gray code counter begins with an initialization phase.
• When the synchronous reset signal is asserted (active-high), all three D flipflops in the counter are synchronously reset to their initial state, which is
typically all zeros (binary 000).
• This ensures a well-defined starting point for the counter's operation.
2. Clock Triggered Operation:
• After initialization, the 3-bit Gray code counter starts counting based on the
clock signal.
• At each rising edge of the clock signal, the binary value stored in the counter is
updated according to the Gray code sequence.
• The Gray code sequence is designed such that only one-bit changes at a time
between consecutive values, which reduces errors during transitions. At each
rising edge of the clock signal, the binary value stored in the counter shifts one
position to the left.
3. Gray Code Sequence Generation:
• The sequence generated by the 3-bit Gray code counter follows the Gray code
pattern, where only one bit changes between adjacent values.
• For a 3-bit Gray code counter, the sequence proceeds as: 000, 001, 011, 010,
110, 111, 101, 100.
• This sequence ensures that only one-bit changes at each step, minimizing
glitches and errors during transitions.
4. Updating the Counter:
• During each clock cycle, the counter's binary value is updated based on the
Gray code pattern.
• The flip-flops are connected in such a way that the least significant bit (LSB)
follows the clock signal directly, while the higher-order bits are influenced by
the previous flip-flops.
• This connection ensures that only one bit changes at a time, maintaining the
Gray code sequence.
5. Asynchronous Reset Handling:
• Similar to the Johnson counter, the synchronous reset feature is essential for
the Gray code counter as well.
• If the synchronous reset signal is asserted, all flip-flops in the 3-bit Gray code
counter are reset to their initial state (000).
• This ensures a reliable and consistent initialization, preventing any ambiguity
during startup.
• In summary, a 3-bit Gray code counter using D flip-flops generates a cyclic
sequence of values following the Gray code pattern. The counter's operation is
synchronized with a clock signal, and its behavior is designed to minimize errors
during transitions by changing only one bit at a time. Synchronous reset
guarantees a predictable starting state for the counter.
6.Testing and Verification using OOP Concept:
Using an OOP approach for testing involves structuring of code using classes
and objects. This methodology helps in creating organized, modular, and
reusable code
• It involves defining of gray code counter class, testbench class, running of
different test cases.
• The logic of the counter is then implemented in the code.
• For each test case, the test bench simulates specific conditions (like clock
toggling, resetting, etc.) and checks if the counter's output matches the
expected output.
In summary, the OOP approach helps organize the testing process into
separate classes, in order to focus on each component's behavior and
interaction. It promotes modularity, reusability, and easier maintenance of your
testing code

### ***Excitation Table*** ###

![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/8b71b0ad-354c-4139-afa5-d4aeae87c509)

<br>

##	***Working of Code*** ##

• D Flip Flop code:
This module represents D flip-flop module with synchronous reset capability. The
module has inputs for data (D), reset, and clock (clk), as well as outputs for the flipflop state (Q) and its complement (Qb). It has an always block triggered by either a
rising clock edge or a rising reset edge, the flip-flop behaves such that when the
reset signal is active, the outputs Q and Qb are set to 0 and 1 respectively. When
reset is inactive, the flip-flop captures the input data D on the rising clock edge,
simultaneously producing Q as D and Qb as the complement of D.

• Gray Code Counter Structural Code:
This Verilog code defines a 3-bit Gray code counter module with synchronous reset
functionality. It takes input signals for clock (clk) and reset (reset), and outputs a 3-bit
Gray applications.

• Gray Code Using OOP :
This System Verilog code defines a package named gray_pkg, wrapping a class
named GrayCounter to model a 3-bit Gray code counter. The class holds member
variables for the counter's state (q), clock input (clk), and reset input (reset). The
constructor initializes the class's members with provided inputs. The update function
implements the counter's logic by shifting the current state and XORing specific bits
to generate the Gray code sequence. The getOutput function returns the current
state when reset is not active, and 0 when reset is asserted. This wrapped class
provides an organized and reusable way to simulate and work with a 3-bit Gray code
counter in digital designs.

• Testbench to compare Outputs:
This System Verilog code defines a package named gray_pkg, encapsulating a
classnamed GrayCounter to model a 3-bit Gray code counter. The class holds
member variables for the counter's state (q), clock input (clk), and reset input (reset).
The constructor initializes the class's members with provided inputs. The update
function implements the counter's logic by shifting the current state and XORing
specific bits to generate the Gray code sequence. The getoutput function returns the
current state when reset is not active, and 0 when reset is asserted. This
encapsulated classprovides an organized and reusable way to simulate and work
with a 3-bit Gray codecounter in digital designs.

##	***Results and Discussion*** ##

In this project, a 3-bit Gray Code Counter D flip-flops is executed using Verilog
code. The counter possesses the ability to count gray code sequence in ascending
order, and it includesa synchronous reset feature. When the reset signal is activated,
the counter reliably initializes to the 3-bit zeroes (000).
The 3-bit gray code counter generates a sequence of: 000, 001, 011, 010, 110, 111,
101, 100. It updates its count in sync with the clock signal, making sure that everything
happens at the right time.
The following waveform can be observed after the execution of the code.

### ***Waveform*** ###
![image](https://github.com/tusharshenoy/3-BIT-Gray-Code-Counter/assets/107348474/12835970-754c-4663-adec-82cda67a865b)


##	***Conclusion*** ##

In conclusion, the project successfully designed a 3-bit gray code counter using
D flip-flops, featuring a synchronous reset. The detailed code implementation is
provided in this report, a comprehensive discussion about the counter's intended
behavior is also included. The designed Gray Code Counter efficiently generates the
cyclic sequence: 000, 001, 011, 010, 110, 111, 101, 100.
The 3-bit Gray Code Counter holds potential applications and they are widely
used in rotary encoders to precisely measure rotation, avoiding errors that could arise
from traditional binary counting methods.
In simple term a gray code counter is a special type of counter that counts in a
specific way, it goes up from 000 till 100. These key features collectively contribute to
the counter's effectiveness and versatility, making it a valuable component for various
applications that require sequential and cyclic behavior. A detailed code and
explanation of the same along with the output waveform is included in this report


##	***References*** ##

1. Javatpoint. Verilog Gray Counter. Retrieved from https:[//www.javatpoint.com/verilog-gray-counter](//www.javatpoint.com/verilog-gray-counter)

2. YouTube. 3-Bit gray code counters circuit diagram. Retrieved from https:[//www.youtube.com/watch?v=gRH_gSrSk8k](//www.youtube.com/watch?v=gRH_gSrSk8k)

3. BrainKart. Synchronous counter design. Retrieved from https:[//www.brainkart.com/article/Design-ofSynchronous-Counters_12975/](//www.brainkart.com/article/Design-ofSynchronous-Counters_12975/)




